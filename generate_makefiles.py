import json
import re
import shutil

# Get compilation instructions from json
# file generated by Trail of Bit people
directories = {}
def collect_compilation_commands():
    global directories

    data = json.load(open("compile_commands.json_small", "r"))
    for d in data:

        directory = d['directory']
        if not directory in directories:
            directories[directory] = []

        directories[directory].append(d['command'])

# Given a cmd, remake it according to
# common values I noticed before, like flags and include dirs
def remake_cmd(d, cmd):
    # List common flags
    flags = ['-DFORTIFY_SOURCE=0 ', '-DLINUX ', '-Derrno=__cgc_errno ', '-fno-builtin ', '-w ', '-g3', '-m32 ', '-fno-stack-protector ']
    cflags = ['-std=gnu99']
    cxxflags = ['-std=gnu++11', '-g ']

    # List common includes
    includes = ['-Iinclude/tiny-AES128-C', '-Iinclude ']
    pov_includes = ['-Iinclude/libpov/pov', '-Iinclude/libpov']

    # Start by renaming the compiler
    cmd = cmd.replace('gcc', '$(CC) $(CFLAGS) $(INCLUDE)')
    cmd = cmd.replace('g++', '$(CXX) $(CXXFLAGS) $(INCLUDE)')

    # Reducing flags
    for f in flags:
        cmd = cmd.replace(f, ' ')

    # Reducing includes
    for i in includes:
        cmd = cmd.replace(i, ' ')

    # Reducing pov includes
    for p in pov_includes:
        cmd = cmd.replace(p, ' ')

    # The same for c
    if '$(CC)' in cmd:
        for f in cflags:
            cmd = cmd.replace(f, ' ')

    # Now for C++
    if '$(CXX)' in cmd:
        for f in cxxflags:
            cmd = cmd.replace(f, ' ')

    # Add includes for POV
    if 'pov' in cmd:
        cmd = cmd.replace('$(INCLUDE)', '$(POV_INCLUDE)')

    # Remove Directory name from cmd
    # and group binaries respectivelly to its files
    cmd = re.sub('%s[^/\s]*/' % d, ' ', cmd)

    # Remove extra spaces
    return re.sub('\s+', ' ', cmd)
    
# Inflates the makefile template and returns its results
# patched_cmds = a list of commands that compile a patched file
# vuln_cmds    = a list of commands that compile a vulnerable (not patched) file
# pov_cmds     = a list of commands that compile a pov file
# obj_files    = a list of all object files for this challenge
# exec_files   = a list of all executable files for this challenge
templatename = 'makefile_template'
def inflate_makefile(d, patched_cmds, vuln_cmds, pov_cmds, obj_files, exec_files):
    c = open(templatename, "r").read()
    c = c.replace("%CHAL%", d)
    c = c.replace("%PATCHED_CMDS%", "\n\t".join(patched_cmds))
    c = c.replace("%VULN_CMDS%", "\n\t".join(vuln_cmds))
    c = c.replace("%POV_CMDS%", "\n\t".join(pov_cmds))
    c = c.replace("%OBJ_FILES%", " ".join(obj_files))
    c = c.replace("%EXECS%", " ".join(exec_files))
    return c

# Extract elements from a cmd
def extract_elements(d, cmds):
    patched_cmds = []
    vuln_cmds    = []
    pov_cmds     = []
    obj_files    = []
    exec_files   = []

    patched_execs = {}
    vuln_execs    = {}
    pov_execs     = {}

    for cmd in cmds:

        # Before striping out challenge name, figure out
        # which type of executable that one is

        m = re.search(r' %s[^\.]*(?!=\.dir)' % d, cmd)
        exe = m.group().strip()

        # Now it's OK to strip it out
        cmd = remake_cmd(d, cmd)

        m = re.search(r' [^\s]+\.o', cmd)
        obj = m.group().strip()
        obj_files.append(obj)

        if 'pov_' in cmd:
            pov_cmds.append(cmd)

            if exe not in pov_execs:
                pov_execs[exe] = []
                exec_files.append(exe)

            pov_execs[exe].append(obj)

        elif 'DPATCHED' in cmd:
            patched_cmds.append(cmd)

            if exe not in patched_execs:
                patched_execs[exe] = []
                exec_files.append(exe)

            patched_execs[exe].append(obj)

        else:
            vuln_cmds.append(cmd)

            if exe not in vuln_execs:
                vuln_execs[exe] = []
                exec_files.append(exe)

            vuln_execs[exe].append(obj)

    [patched_cmds.append("$(CC) $(FLAGS) -o %s %s $(LCGC) " % (k, " ".join(patched_execs[k]))) for k in patched_execs]
    [vuln_cmds   .append("$(CC) $(FLAGS) -o %s %s $(LCGC) " % (k, " ".join(vuln_execs[k])))    for k in vuln_execs]
    [pov_cmds    .append("$(CC) $(FLAGS) -o %s %s $(LPOV) " % (k, " ".join(pov_execs[k])))     for k in pov_execs]

    return patched_cmds, vuln_cmds, pov_cmds, obj_files, exec_files

def generate_makefile():
    blacklist_challenges = open('blacklisted_challenges', 'r').read().split()

    start = 1
    for d in directories:
        if d in blacklist_challenges:
            continue

        print "Creating %s: " % d
        
        # Generate makefiles
        p, v, pv, o, e = extract_elements(d, directories[d])
        m = inflate_makefile(d, p, v, pv, o, e)

        # Copy an individual challenge do a new test case structure directory
        id_str = str(start).zfill(3)
        start += 1

        shutil.copytree('trailofbits/challenges/%s' % d, 'testcases/000/%s' % id_str)

        f = open("testcases/000/%s/Makefile" % (id_str), "w")
        f.write(m)
        f.close()
        print
        print

collect_compilation_commands()
generate_makefile()


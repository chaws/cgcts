import json
import re
import shutil
import os
import sys
import subprocess as shell

# import patches
import generate_makefiles_patches as patches

# Go one dir up, to work on the root
os.chdir('..')

# Get compilation instructions from json
# file generated by Trail of Bit people
directories = {}
def collect_compilation_commands():
    global directories

    data = json.load(open("compile_commands.json_small", "r"))
    for d in data:

        directory = d['directory']
        if not directory in directories:
            directories[directory] = []

        directories[directory].append(d['command'])

# Given a cmd, remake it according to
# common values I noticed before, like flags and include dirs
def remake_cmd(d, cmd):
    # List common flags
    flags = ['-DFORTIFY_SOURCE=0 ', '-DLINUX ', '-Derrno=__cgc_errno ', '-fno-builtin ', '-w ', '-g3', '-m32 ', '-fno-stack-protector ']
    cflags = ['-std=gnu99']
    cxxflags = ['-std=gnu++11', '-g ']

    # List common includes
    includes = ['-Iinclude/tiny-AES128-C', '-Iinclude ']
    pov_includes = ['-Iinclude/libpov/pov', '-Iinclude/libpov']

    # Start by renaming the compiler
    cmd = cmd.replace('gcc', '$(CC) $(CFLAGS) $(INCLUDE)')
    cmd = cmd.replace('g++', '$(CXX) $(CXXFLAGS) $(INCLUDE)')

    # Reducing flags
    for f in flags:
        cmd = cmd.replace(f, ' ')

    # Reducing includes
    for i in includes:
        cmd = cmd.replace(i, ' ')

    # Reducing pov includes
    for p in pov_includes:
        cmd = cmd.replace(p, ' ')

    # The same for c
    if '$(CC)' in cmd:
        for f in cflags:
            cmd = cmd.replace(f, ' ')

    # Now for C++
    if '$(CXX)' in cmd:
        for f in cxxflags:
            cmd = cmd.replace(f, ' ')

    # Add includes for POV
    if 'pov' in cmd:
        cmd = cmd.replace('$(INCLUDE)', '$(POV_INCLUDE)')

    # Remove Directory name from cmd
    # and group binaries respectivelly to its files
    cmd = re.sub('%s[^/\s]*/' % d, ' ', cmd)

    # Remove extra spaces
    return re.sub('\s+', ' ', cmd)
    
# Inflates the makefile template and returns its results
# patched_cmds = a list of commands that compile a patched file
# vuln_cmds    = a list of commands that compile a vulnerable (not patched) file
# pov_cmds     = a list of commands that compile a pov file
# obj_files    = a list of all object files for this challenge
# exec_files   = a list of all executable files for this challenge
templatename = 'makefile_template'
def inflate_makefile(d, patched_cmds, vuln_cmds, pov_cmds, obj_files, exec_files):
    c = open(templatename, "r").read()
    c = c.replace("%CHAL%", d)
    c = c.replace("%PATCHED_CMDS%", "\n\t".join(patched_cmds))
    c = c.replace("%VULN_CMDS%", "\n\t".join(vuln_cmds))
    c = c.replace("%POV_CMDS%", "\n\t".join(pov_cmds))
    c = c.replace("%OBJ_FILES%", " ".join(obj_files))
    c = c.replace("%EXECS%", " ".join(exec_files))
    return c

# Extract elements from a cmd
def extract_elements(d, cmds):
    patched_cmds = []
    vuln_cmds    = []
    pov_cmds     = []
    obj_files    = []
    exec_files   = []

    patched_execs = {}
    vuln_execs    = {}
    pov_execs     = {}

    for cmd in cmds:

        # Before striping out challenge name, figure out
        # which type of executable that one is

        m = re.search(r' %s[^\.]*(?!=\.dir)' % d, cmd)
        exe = m.group().strip()

        # Now it's OK to strip it out
        cmd = remake_cmd(d, cmd)

        # Make sure not to have -Oz
        cmd = cmd.replace('-Oz ', '-Os ')

        m = re.search(r' [^\s]+\.o', cmd)
        obj = m.group().strip()
        obj_files.append(obj)

        if 'pov_' in cmd:
            pov_cmds.append(cmd)

            if exe not in pov_execs:
                pov_execs[exe] = []
                exec_files.append(exe)

            pov_execs[exe].append(obj)

        elif 'DPATCHED' in cmd:
            patched_cmds.append(cmd)

            if exe not in patched_execs:
                patched_execs[exe] = []
                exec_files.append(exe)

            patched_execs[exe].append(obj)

        else:
            vuln_cmds.append(cmd)

            if exe not in vuln_execs:
                vuln_execs[exe] = []
                exec_files.append(exe)

            vuln_execs[exe].append(obj)

    [patched_cmds.append("$(CXX) $(FLAGS) -o %s %s $(LCGC) " % (k, " ".join(patched_execs[k]))) for k in patched_execs]
    [vuln_cmds   .append("$(CXX) $(FLAGS) -o %s %s $(LCGC) " % (k, " ".join(vuln_execs[k])))    for k in vuln_execs]
    [pov_cmds    .append("$(CXX) $(FLAGS) -o %s %s $(LPOV) " % (k, " ".join(pov_execs[k])))     for k in pov_execs]

    return patched_cmds, vuln_cmds, pov_cmds, obj_files, exec_files


patches_challenges = patches.patches.keys()
def do_patch(challenge_name, id_str):

    if challenge_name not in patches_challenges:
        return

    # List of patches for this challenge
    p = patches.patches[challenge_name]
    for file_name in p:
        f = open('testcases/000/%s/%s' % (id_str, file_name), 'r')
        c = f.read()
        f.close()

        # Apply changes in that file
        for changes in p[file_name]:
            search, replace = changes
            c = c.replace(search, replace)
        
        # Save to the same file
        f = open('testcases/000/%s/%s' % (id_str, file_name), 'w')
        f.write(c)
        f.close()

def generate_makefile():
    # List of ignores challenges
    blacklist_challenges = open('blacklisted_challenges', 'r').read().split()

    # List of challenges that were already processed
    processed_challenges = open('processed_challenges', 'r').read().split()

    # Map challenges names to id_str
    name2idstr = ''

    start = 1 + len(processed_challenges)
    for d in directories:

        # Skip black listed challenges
        if d in blacklist_challenges or d in processed_challenges:
            continue

        print "Creating %s: " % d
        
        # Generate makefiles
        p, v, pv, o, e = extract_elements(d, directories[d])
        m = inflate_makefile(d, p, v, pv, o, e)

        # Copy an individual challenge do a new test case structure directory
        id_str = str(start).zfill(3)
        shutil.copytree('trailofbits/challenges/%s' % d, 'testcases/000/%s' % id_str)
        start += 1

        # Patch if needed
        do_patch(d, id_str)

        f = open("testcases/000/%s/Makefile" % (id_str), "w")
        f.write(m)
        f.close()

        # Make sure it compiles alright
        caused_error = shell.call(['make', '-C', 'testcases/000/%s' % (id_str)])
        if caused_error:
            print "Coudn't build '%s', quitting" % d

            # Delete its directory
            shutil.rmtree('testcases/000/%s' % id_str)
            break

        # If it got to here, all's good

        # Add new challenge map entry
        name2idstr += "%s %s\n" % (d, id_str)
        processed_challenges.append(d)

        print
        print
    # end-for

    # Update mapping file with challenge names and sard ids
    f = open('original2sard', 'w+')
    f.write(name2idstr)
    f.close()

    # Update file containing processed challenges
    f = open('processed_challenges', 'w')
    [f.write("%s\n" % pc) for pc in processed_challenges]
    f.close()

collect_compilation_commands()
generate_makefile()

